/**
* pbforwarder API
* Policy-Based Forwarder Service
*
* OpenAPI spec version: 2.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/polycube-network/swagger-codegen.git
* branch polycube
*/


/* Do not edit this file manually */



#include "RulesJsonObject.h"
#include <regex>

namespace io {
namespace swagger {
namespace server {
namespace model {

RulesJsonObject::RulesJsonObject() :
  m_idIsSet (false),
  m_vlanIsSet (false),
  m_srcMacIsSet (false),
  m_dstMacIsSet (false),
  m_srcIpIsSet (false),
  m_dstIpIsSet (false),
  m_l4Proto (RulesL4ProtoEnum::TCP),
  m_l4ProtoIsSet (true),
  m_srcPortIsSet (false),
  m_dstPortIsSet (false),
  m_inPortIsSet (false),
  m_outPortIsSet (false),
  m_action (RulesActionEnum::DROP),
  m_actionIsSet (true) { }

RulesJsonObject::RulesJsonObject(nlohmann::json& val) :
  m_idIsSet (false),
  m_vlanIsSet (false),
  m_srcMacIsSet (false),
  m_dstMacIsSet (false),
  m_srcIpIsSet (false),
  m_dstIpIsSet (false),
  // Item with a default value, granted to be part of the request body
  m_l4Proto (string_to_RulesL4ProtoEnum(val.at("l4_proto").get<std::string>())),
  m_l4ProtoIsSet (true),
  m_srcPortIsSet (false),
  m_dstPortIsSet (false),
  m_inPortIsSet (false),
  m_outPortIsSet (false),
  // Item with a default value, granted to be part of the request body
  m_action (string_to_RulesActionEnum(val.at("action").get<std::string>())),
  m_actionIsSet (true) {

  if (val.count("vlan") != 0) {
    setVlan(val.at("vlan").get<uint32_t>());
  }

  if (val.count("src_mac") != 0) {
    setSrcMac(val.at("src_mac").get<std::string>());
  }

  if (val.count("dst_mac") != 0) {
    setDstMac(val.at("dst_mac").get<std::string>());
  }

  if (val.count("src_ip") != 0) {
    setSrcIp(val.at("src_ip").get<std::string>());
  }

  if (val.count("dst_ip") != 0) {
    setDstIp(val.at("dst_ip").get<std::string>());
  }


  if (val.count("src_port") != 0) {
    setSrcPort(val.at("src_port").get<uint16_t>());
  }

  if (val.count("dst_port") != 0) {
    setDstPort(val.at("dst_port").get<uint16_t>());
  }

  if (val.count("in_port") != 0) {
    setInPort(val.at("in_port").get<std::string>());
  }

  if (val.count("out_port") != 0) {
    setOutPort(val.at("out_port").get<std::string>());
  }

}

nlohmann::json RulesJsonObject::toJson() const {
  nlohmann::json val = nlohmann::json::object();

  val["id"] = m_id;
  if (m_vlanIsSet) {
    val["vlan"] = m_vlan;
  }

  if (m_srcMacIsSet) {
    val["src_mac"] = m_srcMac;
  }

  if (m_dstMacIsSet) {
    val["dst_mac"] = m_dstMac;
  }

  if (m_srcIpIsSet) {
    val["src_ip"] = m_srcIp;
  }

  if (m_dstIpIsSet) {
    val["dst_ip"] = m_dstIp;
  }

  if (m_l4ProtoIsSet) {
    val["l4_proto"] = RulesL4ProtoEnum_to_string(m_l4Proto);
  }

  if (m_srcPortIsSet) {
    val["src_port"] = m_srcPort;
  }

  if (m_dstPortIsSet) {
    val["dst_port"] = m_dstPort;
  }

  if (m_inPortIsSet) {
    val["in_port"] = m_inPort;
  }

  if (m_outPortIsSet) {
    val["out_port"] = m_outPort;
  }

  if (m_actionIsSet) {
    val["action"] = RulesActionEnum_to_string(m_action);
  }


  return val;
}

nlohmann::json RulesJsonObject::helpKeys() {
  nlohmann::json val = nlohmann::json::object();

  val["id"]["name"] = "id";
  val["id"]["type"] = "key";
  val["id"]["simpletype"] = "integer";
  val["id"]["description"] = R"POLYCUBE(Rule Identifier)POLYCUBE";
  val["id"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

nlohmann::json RulesJsonObject::helpElements() {
  nlohmann::json val = nlohmann::json::object();

  val["vlan"]["name"] = "vlan";
  val["vlan"]["type"] = "leaf"; // Suppose that type is leaf
  val["vlan"]["simpletype"] = "integer";
  val["vlan"]["description"] = R"POLYCUBE(VLAN Identifier)POLYCUBE";
  val["vlan"]["example"] = R"POLYCUBE()POLYCUBE";
  val["src_mac"]["name"] = "src_mac";
  val["src_mac"]["type"] = "leaf"; // Suppose that type is leaf
  val["src_mac"]["simpletype"] = "string";
  val["src_mac"]["description"] = R"POLYCUBE(Source MAC Address in the form AA:BB:CC:DD:EE:FF)POLYCUBE";
  val["src_mac"]["example"] = R"POLYCUBE()POLYCUBE";
  val["dst_mac"]["name"] = "dst_mac";
  val["dst_mac"]["type"] = "leaf"; // Suppose that type is leaf
  val["dst_mac"]["simpletype"] = "string";
  val["dst_mac"]["description"] = R"POLYCUBE(Destination MAC Address in the form AA:BB:CC:DD:EE:FF)POLYCUBE";
  val["dst_mac"]["example"] = R"POLYCUBE()POLYCUBE";
  val["src_ip"]["name"] = "src_ip";
  val["src_ip"]["type"] = "leaf"; // Suppose that type is leaf
  val["src_ip"]["simpletype"] = "string";
  val["src_ip"]["description"] = R"POLYCUBE(Source IP Address in the form AA.BB.CC.DD)POLYCUBE";
  val["src_ip"]["example"] = R"POLYCUBE()POLYCUBE";
  val["dst_ip"]["name"] = "dst_ip";
  val["dst_ip"]["type"] = "leaf"; // Suppose that type is leaf
  val["dst_ip"]["simpletype"] = "string";
  val["dst_ip"]["description"] = R"POLYCUBE(Destination IP Address in the form AA.BB.CC.DD)POLYCUBE";
  val["dst_ip"]["example"] = R"POLYCUBE()POLYCUBE";
  val["l4_proto"]["name"] = "l4_proto";
  val["l4_proto"]["type"] = "leaf"; // Suppose that type is leaf
  val["l4_proto"]["simpletype"] = "string";
  val["l4_proto"]["description"] = R"POLYCUBE(Level 4 Protocol (i.e. UDP, TCP; default: TCP))POLYCUBE";
  val["l4_proto"]["example"] = R"POLYCUBE()POLYCUBE";
  val["src_port"]["name"] = "src_port";
  val["src_port"]["type"] = "leaf"; // Suppose that type is leaf
  val["src_port"]["simpletype"] = "integer";
  val["src_port"]["description"] = R"POLYCUBE(Source L4 Port)POLYCUBE";
  val["src_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["dst_port"]["name"] = "dst_port";
  val["dst_port"]["type"] = "leaf"; // Suppose that type is leaf
  val["dst_port"]["simpletype"] = "integer";
  val["dst_port"]["description"] = R"POLYCUBE(Destination L4 Port)POLYCUBE";
  val["dst_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["in_port"]["name"] = "in_port";
  val["in_port"]["type"] = "leaf"; // Suppose that type is leaf
  val["in_port"]["simpletype"] = "string";
  val["in_port"]["description"] = R"POLYCUBE(Ingress port)POLYCUBE";
  val["in_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["out_port"]["name"] = "out_port";
  val["out_port"]["type"] = "leaf"; // Suppose that type is leaf
  val["out_port"]["simpletype"] = "string";
  val["out_port"]["description"] = R"POLYCUBE(Output port (used only when action is FORWARD))POLYCUBE";
  val["out_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["action"]["name"] = "action";
  val["action"]["type"] = "leaf"; // Suppose that type is leaf
  val["action"]["simpletype"] = "string";
  val["action"]["description"] = R"POLYCUBE(Action associated to the rule(i.e., DROP, SLOWPATH, or FORWARD; default: DROP))POLYCUBE";
  val["action"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

nlohmann::json RulesJsonObject::helpWritableLeafs() {
  nlohmann::json val = nlohmann::json::object();

  val["vlan"]["name"] = "vlan";
  val["vlan"]["simpletype"] = "integer";
  val["vlan"]["description"] = R"POLYCUBE(VLAN Identifier)POLYCUBE";
  val["vlan"]["example"] = R"POLYCUBE()POLYCUBE";
  val["src_mac"]["name"] = "src_mac";
  val["src_mac"]["simpletype"] = "string";
  val["src_mac"]["description"] = R"POLYCUBE(Source MAC Address in the form AA:BB:CC:DD:EE:FF)POLYCUBE";
  val["src_mac"]["example"] = R"POLYCUBE()POLYCUBE";
  val["dst_mac"]["name"] = "dst_mac";
  val["dst_mac"]["simpletype"] = "string";
  val["dst_mac"]["description"] = R"POLYCUBE(Destination MAC Address in the form AA:BB:CC:DD:EE:FF)POLYCUBE";
  val["dst_mac"]["example"] = R"POLYCUBE()POLYCUBE";
  val["src_ip"]["name"] = "src_ip";
  val["src_ip"]["simpletype"] = "string";
  val["src_ip"]["description"] = R"POLYCUBE(Source IP Address in the form AA.BB.CC.DD)POLYCUBE";
  val["src_ip"]["example"] = R"POLYCUBE()POLYCUBE";
  val["dst_ip"]["name"] = "dst_ip";
  val["dst_ip"]["simpletype"] = "string";
  val["dst_ip"]["description"] = R"POLYCUBE(Destination IP Address in the form AA.BB.CC.DD)POLYCUBE";
  val["dst_ip"]["example"] = R"POLYCUBE()POLYCUBE";
  val["l4_proto"]["name"] = "l4_proto";
  val["l4_proto"]["simpletype"] = "string";
  val["l4_proto"]["description"] = R"POLYCUBE(Level 4 Protocol (i.e. UDP, TCP; default: TCP))POLYCUBE";
  val["l4_proto"]["example"] = R"POLYCUBE()POLYCUBE";
  val["src_port"]["name"] = "src_port";
  val["src_port"]["simpletype"] = "integer";
  val["src_port"]["description"] = R"POLYCUBE(Source L4 Port)POLYCUBE";
  val["src_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["dst_port"]["name"] = "dst_port";
  val["dst_port"]["simpletype"] = "integer";
  val["dst_port"]["description"] = R"POLYCUBE(Destination L4 Port)POLYCUBE";
  val["dst_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["in_port"]["name"] = "in_port";
  val["in_port"]["simpletype"] = "string";
  val["in_port"]["description"] = R"POLYCUBE(Ingress port)POLYCUBE";
  val["in_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["out_port"]["name"] = "out_port";
  val["out_port"]["simpletype"] = "string";
  val["out_port"]["description"] = R"POLYCUBE(Output port (used only when action is FORWARD))POLYCUBE";
  val["out_port"]["example"] = R"POLYCUBE()POLYCUBE";
  val["action"]["name"] = "action";
  val["action"]["simpletype"] = "string";
  val["action"]["description"] = R"POLYCUBE(Action associated to the rule(i.e., DROP, SLOWPATH, or FORWARD; default: DROP))POLYCUBE";
  val["action"]["example"] = R"POLYCUBE()POLYCUBE";

  return val;
}

nlohmann::json RulesJsonObject::helpComplexElements() {
  nlohmann::json val = nlohmann::json::object();


  return val;
}

std::vector<std::string> RulesJsonObject::helpActions() {
  std::vector<std::string> val;
  return val;
}

uint32_t RulesJsonObject::getId() const {
  return m_id;
}

void RulesJsonObject::setId(uint32_t value) {
  m_id = value;
  m_idIsSet = true;
}

bool RulesJsonObject::idIsSet() const {
  return m_idIsSet;
}





uint32_t RulesJsonObject::getVlan() const {
  return m_vlan;
}

void RulesJsonObject::setVlan(uint32_t value) {
  m_vlan = value;
  m_vlanIsSet = true;
}

bool RulesJsonObject::vlanIsSet() const {
  return m_vlanIsSet;
}

void RulesJsonObject::unsetVlan() {
  m_vlanIsSet = false;
}



std::string RulesJsonObject::getSrcMac() const {
  return m_srcMac;
}

void RulesJsonObject::setSrcMac(std::string value) {
  m_srcMac = value;
  m_srcMacIsSet = true;
}

bool RulesJsonObject::srcMacIsSet() const {
  return m_srcMacIsSet;
}

void RulesJsonObject::unsetSrcMac() {
  m_srcMacIsSet = false;
}



std::string RulesJsonObject::getDstMac() const {
  return m_dstMac;
}

void RulesJsonObject::setDstMac(std::string value) {
  m_dstMac = value;
  m_dstMacIsSet = true;
}

bool RulesJsonObject::dstMacIsSet() const {
  return m_dstMacIsSet;
}

void RulesJsonObject::unsetDstMac() {
  m_dstMacIsSet = false;
}



std::string RulesJsonObject::getSrcIp() const {
  return m_srcIp;
}

void RulesJsonObject::setSrcIp(std::string value) {
  m_srcIp = value;
  m_srcIpIsSet = true;
}

bool RulesJsonObject::srcIpIsSet() const {
  return m_srcIpIsSet;
}

void RulesJsonObject::unsetSrcIp() {
  m_srcIpIsSet = false;
}



std::string RulesJsonObject::getDstIp() const {
  return m_dstIp;
}

void RulesJsonObject::setDstIp(std::string value) {
  m_dstIp = value;
  m_dstIpIsSet = true;
}

bool RulesJsonObject::dstIpIsSet() const {
  return m_dstIpIsSet;
}

void RulesJsonObject::unsetDstIp() {
  m_dstIpIsSet = false;
}



RulesL4ProtoEnum RulesJsonObject::getL4Proto() const {
  return m_l4Proto;
}

void RulesJsonObject::setL4Proto(RulesL4ProtoEnum value) {
  m_l4Proto = value;
  m_l4ProtoIsSet = true;
}

bool RulesJsonObject::l4ProtoIsSet() const {
  return m_l4ProtoIsSet;
}

void RulesJsonObject::unsetL4Proto() {
  m_l4ProtoIsSet = false;
}

std::string RulesJsonObject::RulesL4ProtoEnum_to_string(const RulesL4ProtoEnum &value){
  switch(value){
    case RulesL4ProtoEnum::UDP:
      return std::string("udp");
    case RulesL4ProtoEnum::TCP:
      return std::string("tcp");
    default:
      throw std::runtime_error("Bad Rules l4Proto");
  }
}

RulesL4ProtoEnum RulesJsonObject::string_to_RulesL4ProtoEnum(const std::string &str){
  if (JsonObjectBase::iequals("udp", str))
    return RulesL4ProtoEnum::UDP;
  if (JsonObjectBase::iequals("tcp", str))
    return RulesL4ProtoEnum::TCP;
  throw std::runtime_error("Rules l4Proto is invalid");
}


uint16_t RulesJsonObject::getSrcPort() const {
  return m_srcPort;
}

void RulesJsonObject::setSrcPort(uint16_t value) {
  m_srcPort = value;
  m_srcPortIsSet = true;
}

bool RulesJsonObject::srcPortIsSet() const {
  return m_srcPortIsSet;
}

void RulesJsonObject::unsetSrcPort() {
  m_srcPortIsSet = false;
}



uint16_t RulesJsonObject::getDstPort() const {
  return m_dstPort;
}

void RulesJsonObject::setDstPort(uint16_t value) {
  m_dstPort = value;
  m_dstPortIsSet = true;
}

bool RulesJsonObject::dstPortIsSet() const {
  return m_dstPortIsSet;
}

void RulesJsonObject::unsetDstPort() {
  m_dstPortIsSet = false;
}



std::string RulesJsonObject::getInPort() const {
  return m_inPort;
}

void RulesJsonObject::setInPort(std::string value) {
  m_inPort = value;
  m_inPortIsSet = true;
}

bool RulesJsonObject::inPortIsSet() const {
  return m_inPortIsSet;
}

void RulesJsonObject::unsetInPort() {
  m_inPortIsSet = false;
}



std::string RulesJsonObject::getOutPort() const {
  return m_outPort;
}

void RulesJsonObject::setOutPort(std::string value) {
  m_outPort = value;
  m_outPortIsSet = true;
}

bool RulesJsonObject::outPortIsSet() const {
  return m_outPortIsSet;
}

void RulesJsonObject::unsetOutPort() {
  m_outPortIsSet = false;
}



RulesActionEnum RulesJsonObject::getAction() const {
  return m_action;
}

void RulesJsonObject::setAction(RulesActionEnum value) {
  m_action = value;
  m_actionIsSet = true;
}

bool RulesJsonObject::actionIsSet() const {
  return m_actionIsSet;
}

void RulesJsonObject::unsetAction() {
  m_actionIsSet = false;
}

std::string RulesJsonObject::RulesActionEnum_to_string(const RulesActionEnum &value){
  switch(value){
    case RulesActionEnum::DROP:
      return std::string("drop");
    case RulesActionEnum::SLOWPATH:
      return std::string("slowpath");
    case RulesActionEnum::FORWARD:
      return std::string("forward");
    default:
      throw std::runtime_error("Bad Rules action");
  }
}

RulesActionEnum RulesJsonObject::string_to_RulesActionEnum(const std::string &str){
  if (JsonObjectBase::iequals("drop", str))
    return RulesActionEnum::DROP;
  if (JsonObjectBase::iequals("slowpath", str))
    return RulesActionEnum::SLOWPATH;
  if (JsonObjectBase::iequals("forward", str))
    return RulesActionEnum::FORWARD;
  throw std::runtime_error("Rules action is invalid");
}



}
}
}
}


